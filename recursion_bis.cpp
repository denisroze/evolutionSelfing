#include "fisher.h"
#include <iostream>
#include <fstream>
#include <sstream>
#include <ctime>
#include <boost/dynamic_bitset.hpp>
#include <cmath>
#include <csignal>
#include <vector>
#include <algorithm>
using namespace std;

extern MTRand rnd;
extern FILE * fichierE;
extern FILE * fichierS;


/*----------------------------------------------------------
 Function recursion: iterates the life cycle.
 Parameters are:
 Nv: population size (nb of diploid organisms)
 sv: selfing rate
 nv: number of phenotypic dimensions
 mv: pleiotropy
 av: size of mutational steps along each phenotypic axis
 Qv: curvature of fitness function (cf Gros et al 2009 Genetics)
 Uv: mutation rate per genome (on selected loci)
 nbSv: number of selected loci per genome
 Lv: genome map length (mean nb of cross-overs per meiosis)
 mutMv: mutation rate at neutral locus
 NbGenv: number of generations
 pasv: time interval between measurements of neutral diversity and writing in result file
 -----------------------------------------------------------*/


void recursion(int Nv, double sv, int nv, int mv, double sbarv, double omegav, double Qv, double Uv, int nbSv, double Udelv, double selv, double hv, double uneutv, int nbneutv, double Uselfv, double sigselfv, int nbselfv, double Vev, double kappav, double Lv, int NbGenv, int NbGenPreliv, int pasv, int smpv)
{
    // variables:
    
    vector<Nall> Fr;
    Nall allTemp;
    int i, j, k, gen, mut, chr1, ind, nb, nb2, nb3, nb4, parent, prem1, par1, frs, nbf,
    free, site, ns, part, cmpt, nbCo, muM, mutS, nm;
    double w, wbar, wmax, varw, le, rd, rd2, div, pp, hom, d, x, sbar, lnsbar, sbmoy, lnwbar, lnvarw, dg, Sbar,Sgbar, Sgbarsel, Smin, Smax, varS, vsquared, mutincond;
    double wout, lnwout, wself, lnwself, S, m0, av, wmmax, mtot, mstot, vtot, vstot, m3, m4, m5, m6, mouttot, vouttot, mselftot, vselftot, Cov, Third, cov1, cov2, wincond, wincondbar, wphenobar, woutpheno, wselfpheno, woutincond, wselfincond, varwincond, varwpheno;
    int nbFix = 0;
    chr chrTemp1, chrTemp2;
    
    // various fixed quantities:
    int Nn = Nv * nv;
    int twoN = 2*Nv;
    int fourN = 4*Nv;
    int twoN_1 = 2*Nv - 1;
    int nbS_1 = nbSv - 1;
    int nS = nbSv * nv;
    int nbm1 = nbselfv - 1;
    int nbn1 = nbneutv - 1;
    int twonN = 2 * Nv * nv;
    int twon = 2 * nv;
    double uself = Uselfv/nbselfv;
    double hQ = Qv / 2.0;
    double sqrs = sqrt(Vev);
    double Ven = 1/double(nv);
    double sqrn = sqrt(Ven);
    double sigself = sqrt(sigselfv);
    int twoSmp = 2 * smpv;
    int twonSmp = 2 * nv * smpv;
    vector<int> store;
    vector <int> posmut;
    
    // Table "Chrm" holds all the types of genome segments present in the population:
    
    chr * Chrm = new chr [fourN];
    
    // table "pop" contains 2N pointers to "chr" elements of the Chrm table
    // (one pointer for each genome segment in the population).
    // "temp" is used during the formation of the next generation:
    
    chr ** pop = new chr *[twoN];
    chr ** temp = new chr *[twoN];
    
    // "mutations" will hold the effect of the 1 allele at each locus
    // on each phenotypic axis:
    
    double * mutations = new double [nS];
    
    // "pheno" will store the phenotypic distance from the optimum
    // generated by mutations present on the genome segment, for each
    // of the 2N segments and along each axis (2Nn values).
    // "phenoTemp" is used during the formation of the next generation:
    // "selfing" will store the selfing rate of all inidivuals
    
    double * pheno = new double [twonN];
    double * phenoTemp = new double [twonN];
    double * phenoDep = new double [twonSmp];
    float * selfing = new float [Nv];
    
    int * par = new int [twoN];
    int * parDep = new int [twoSmp];
    
    // dominance and selection of unconditionally deleterious mutations
    double Whet = 1 - hv * selv;
    double Whom = 1 - selv;
    
    // "Wtot" will hold the fitness of each individual:
    
    double * Wtot = new double [Nv];
    
    double * m = new double [nv];
    double * ms = new double [nv];
    double * v = new double [nv];
    double * vs = new double [nv];
    
    double * mout = new double [nv];
    double * mself = new double [nv];
    double * vout = new double [nv];
    double * vself = new double [nv];
    
    double * Vg = new double [nv];
    double * Vgintra = new double [nv];
    
    // creates result file (with parameter values in file name):
    
    char nomFichier[256];
    stringstream nomF;
    nomF << "result_N" << Nv << "_n" << nv << "_m" << mv<< "_sbar" << sbarv << "_om2_" << omegav << "_U" << Uv << "_nbS" << nbSv << "_Udel" << Udelv << "_sdel" << selv << "_h" << hv << "_L" << Lv << "_Uself" << Uselfv << "_nbself" << nbselfv << "_sigself" << sigselfv << "_self" << sv << "_Ve"<< Vev << "_kappa" << kappav << ".txt";
    nomF >> nomFichier;
    ofstream fout;
    fout.open(nomFichier);
    
    // for time length measure:
    
    time_t debut, fin;
    struct tm *ptr;
    debut = time(0);
    
    // initialization: allele 0 is fixed at all selected loci. There is a single type
    // of chromosome (containing only 0's), which is the first entry of the "Chrm"
    // table. The number of copies of this genome segment is 2N:
    
    Chrm[0].sel.resize(nbSv);
    
    for (i=0; i< fourN; i++){
        Chrm[i].selfing = new float [nbselfv]; // effects of the different loci of the individual on selfing rate (initially sInitv/nbselfv at each locus)
        Chrm[i].neut = new float [nbneutv]; // alleles at neutral loci (initially 0)
        Chrm[i].incond.clear();
    }
    Chrm[0].nbchr = twoN;
    
    chrTemp1.selfing = new float [nbselfv];
    chrTemp1.neut = new float [nbneutv];
    chrTemp1.incond.clear();
    chrTemp2.selfing = new float [nbselfv];
    chrTemp2.neut = new float [nbneutv];
    chrTemp2.incond.clear();
    
    
    for (k = 0; k < nbneutv; k++)
        Chrm[0].neut[k] = 0;
    for (k = 0; k < nbselfv; k++)
        Chrm[0].selfing[k] = sv/(2*float(nbselfv));
    for (i = 1; i < fourN; i++)
        Chrm[i].nbchr = 0;
    
    // positions of mutation modifier loci (on scale between 0 and 1)
    
    float * modpos = new float [nbselfv];
    for (k = 0; k < nbselfv; k++)
        modpos[k] = (floor((nbSv % (nbselfv+1))/2.0) + (k+1) * floor(nbSv / (nbselfv+1)) + 0.5);
    
    // positions of neutral loci (on scale between 0 and 1)
    
    float * neutpos = new float [nbneutv];
    for (k = 0; k < nbneutv; k++)
        neutpos[k] = (floor((nbSv % (nbneutv+1))/2.0) + (k+1) * floor(nbSv / (nbneutv+1)) + 0.25);
    
    
    // all 2N pointers (one for each chromosome in the population)
    // point towards Chrm[0]:
    
    for (i = 0; i < twoN; i++)
        pop[i] = &Chrm[0];
    
    //Calculates the effect of selection
    if(Qv ==2){
        av = sqrt(sbarv*2*(omegav+Ven)/mv);
    }
    else{
        x = sbarv * (omegav+Ven)*tgamma(nv/2)/tgamma((nv+Qv)/2);
        av = sqrt((nv/mv)*pow(x,(2/Qv)));
    }
    
    
    // samples the effect of allele 1 at each locus on each of the phenotypic axes.
    // stores the result in "mutations" table:
    
    for (i = 0; i < nS; i++)
        mutations[i] = 0;
    for (i = 0; i < nbSv; i++)
    {
        nb = nv * i;
        store.clear();
        for (j = 0; j < mv; j++)
        {
            do
                k = int(nv * rnd.randExc());
            while (find(store.begin(), store.end(), k) != store.end());
            store.push_back(k);
            mutations[nb + k] = av * gasdev();
        }
    }
    
    
    
    // calculates the mean fitness effect of mutations, stores result in sbar, lnsbar variables:
    
    sbar = 0; lnsbar = 0;
    for (i = 0; i < nbSv; i++)
    {
        d = 0;
        nb = i * nv;
        for (j = 0; j < nv; j++){
            d += (mutations[nb+j])  * (mutations[nb+j]);
        }
        
        sbar += 1 - exp(-1/(2 *(omegav + Ven)) * pow(d, hQ));
        lnsbar += 1/(2 *(omegav + Ven)) * pow(d, hQ);
    }
    sbar /= nbSv; lnsbar /= nbSv;
    
    
    // the phenotypic distance from the optimum is 0 along each phenotypic axis:
    
    for (i = 0; i < twonN; i++)
        pheno[i] = 0;
    
    
    //generations:
    
    for (gen = 0; gen < NbGenv; gen++)
    {
        
        lnwbar = 0;
        lnvarw = 0;
        wbar = 0;
        wphenobar=0;
        wincondbar=0;
        wmax = 0;
        varw = 0;
        varwpheno = 0;
        varwincond = 0;
        cmpt = 0;
        Sbar = 0;
        Sgbarsel =0;
        Sgbar = 0;
        Smin = 0;
        Smax = 0;
        varS =0;
        wmmax = 0;
    
        
        for (i = 0; i < Nv; i++)
        {
            nb = twon * i;
            d = 0;
            for (j = 0; j < nv; j++)
            {
                x = pheno[nb + j] + pheno[nb + nv + j];
                d += x * x; // "d" is the square of the distance to the optimum
            }
            
            // fitness of individual i at quantitative traits:
            w = exp(-1/(2*omegav) * pow(d, hQ));
            wphenobar += w;
            varwpheno += w * w;
            
            wincond = fitness((*(pop[2*i])),(*(pop[2*i+1])),Whet, Whom);
            wincondbar += wincond;
            varwincond += wincond * wincond;
            
            w *= wincond;
            
            Wtot[i] = w;
            
            wbar += w;
            varw += w * w;
            if (w > 0)
            {
                lnwbar += log(w);
                lnvarw += log(w) * log(w);
                cmpt++;
            }
            
            if (wmax < w)
                wmax = w;
            
            
            
            // Selfing rate of individual i:
            S=0;
            for (k = 0; k < nbselfv; k++){
                S += (*(pop[2*i])).selfing[k];
                S += (*(pop[2*i+1])).selfing[k];
            }
            
            if (S < 0)
                S = 0;
            if (S > 1)
                S = 1;
            
            Sgbar += S;
            Sgbarsel += S*w;
            varS = S*S;
            
            S += gasdev()*sqrs;
            if (S < 0)
                S = 0;
            if (S > 1)
                S = 1;
            
            selfing[i] = S;
            Sbar += S;
            
            if (Smin > S)
                Smin = S;
            if (Smax < S)
                Smax = S;
            
            
            if (wmmax < (1- S*kappav)*w)
            {
                wmmax =(1- S*kappav)*w;
            }
            
        }
        wbar /= Nv;
        wphenobar /= Nv;
        wincondbar /= Nv;
        varw /= Nv;
        varwpheno /= Nv;
        varwincond /= Nv;
        Sbar /= Nv;
        Sgbar /= Nv;
        Sgbarsel = (Sgbarsel/Nv)/wbar;
        varS /=Nv;
        lnwbar /= cmpt;
        lnvarw /= cmpt;
        
        
        // measures diversity and writes in result file every "pasv" generations:
        
        if (gen % pasv == 0)
        {
            
            
            // average trait values:
            mtot = 0;
            mstot = 0;
            for (i = 0; i < nv; i++)
            {
                m[i] = 0;
                ms[i] = 0;
            }
            for (i = 0; i < Nv; i++)
            {
                nb = twon * i;
                for (j = 0; j < nv; j++)
                {
                    m[j] += (pheno[nb + j] + pheno[nb + nv + j]);
                    ms[j] += (pheno[nb + j] + pheno[nb + nv + j]) * Wtot[i] / wbar;
                }
            }
            for (i = 0; i < nv; i++)
            {
                m[i] /= Nv;
                ms[i] /= Nv;
                mtot+= m[i];
                mstot+= ms[i];
                
            }
            
            // variances:
            vtot = 0;
            vstot = 0;
            vsquared = 0;
            for (i = 0; i < nv; i++)
            {
                v[i] = 0;
                vs[i] = 0;
            }
            for (i = 0; i < Nv; i++)
            {
                nb = twon * i;
                for (j = 0; j < nv; j++)
                {
                    v[j] += pow(pheno[nb + j] + pheno[nb + nv + j] - m[j], 2);
                    vs[j] += pow(pheno[nb + j] + pheno[nb + nv + j] - ms[j], 2) * Wtot[i] / wbar;
                }
            }
            for (i = 0; i < nv; i++)
            {
                v[i] /= Nv;
                vs[i] /= Nv;
                
                vtot+= v[i];
                vstot+= vs[i];
                vsquared += v[i]*v[i];
            }
            
            // third moments:
            
            m3 = 0;
            for (i = 0; i < Nv; i++)
            {
                nb = twon * i;
                for (j = 0; j < nv; j++)
                    m3 += pow(pheno[nb + j] + pheno[nb + nv + j] - m[j], 3);
            }
            m3 /= Nn;
            
            // fourth moments:
            
            m4 = 0;
            for (i = 0; i < Nv; i++)
            {
                nb = twon * i;
                for (j = 0; j < nv; j++)
                    m4 += pow(pheno[nb + j] + pheno[nb + nv + j] - m[j], 4);
            }
            m4 /= Nn;
            
            // fifth moments:
            
            m5 = 0;
            for (i = 0; i < Nv; i++)
            {
                nb = twon * i;
                for (j = 0; j < nv; j++)
                    m5 += pow(pheno[nb + j] + pheno[nb + nv + j] - m[j], 5);
            }
            
            m5 /= Nv;
            
            // sixth moments:
            m6 = 0;
            for (i = 0; i < Nv; i++)
            {
                nb = twon * i;
                for (j = 0; j < nv; j++)
                    m6 += pow(pheno[nb + j] + pheno[nb + nv + j] - m[j], 6);
            }
            
            m6 /= Nv;
            
            // Selfing rates and covariances between selfing and phenotype
            Cov = 0;
            Third = 0;
            
            for (i = 0; i < Nv; i++)
            {
                
                S=0;
                for (k = 0; k < nbselfv; k++){
                    S += (*(pop[2*i])).selfing[k];
                    S += (*(pop[2*i+1])).selfing[k];
                }
                if (S < 0)
                    S = 0;
                if (S > 1)
                    S = 1;
                
                cov2 = S - Sgbar;
                
                nb = twon * i;
                
                for (j = 0; j < nv; j++)
                {
                    x = pheno[nb + j] + pheno[nb + nv + j];
                    
                    cov1 = x - m[j];
                    
                    Cov += cov1*cov2;
                    Third += cov1*cov1*cov2;
                    
                }
                
            }
            
            Cov /= Nv;
            Third /= Nv;
            
            
            // inbreeding depression:
            // sampling parents for outcrossed offspring:
            
            for (i = 0; i < twoSmp; i++)
                parDep[i] = 2 * int(rnd.randExc() * Nv);
            
            // recombination and individual phenotypes and fitnesses:
            wout = 0;
            lnwout = 0;
            cmpt = 0;
            
            for (nb = 0; nb < smpv; nb++)
            {
                
                // maternal sampled parent
                ind = 2*nb;
                nb2 = nv * ind;
                nbCo = int(poisdev(Lv));
                
                
                // if no mutation or cross-over on chromosome segment:
                
                if (nbCo == 0)
                {
                    rd = rnd.rand();
                    if (rd < 0.5)
                        parent = parDep[ind];
                    else
                        parent = parDep[ind] + 1;
                    
                    nb3 = nv * parent;
                    for (j = 0; j < nv; j++)
                        phenoDep[nb2 + j] = pheno[nb3 + j];
                    
                    chrTemp1 = (*(pop[parDep[ind]]));
                    
                }
                else
                {
                    
                    rd = rnd.rand();
                    if (rd < 0.5)
                        rec(chrTemp1, *(pop[parDep[ind]]), *(pop[parDep[ind] + 1]), nbCo, nbSv, nbselfv, nbneutv, modpos, neutpos);
                    else
                        rec(chrTemp1, *(pop[parDep[ind] + 1]), *(pop[parDep[ind]]), nbCo, nbSv, nbselfv, nbneutv, modpos, neutpos);
                    
                    
                    for (j = 0; j < nv; j++)
                    {
                        d = 0;
                        for (k = 0; k < nbSv; k++)
                            if (chrTemp1.sel[k] == 1)
                                d += mutations[nv * k + j];
                        phenoDep[nb2 + j] = d;
                    }
                }
                
                
                // Paternal sampled parent
                ind = (2*nb) + 1;
                nb2 = nv * ind;
                nbCo = int(poisdev(Lv));
                
                
                // if no mutation or cross-over on chromosome segment:
                
                if (nbCo == 0)
                {
                    rd = rnd.rand();
                    if (rd < 0.5)
                        parent = parDep[ind];
                    else
                        parent = parDep[ind] + 1;
                    
                    nb3 = nv * parent;
                    for (j = 0; j < nv; j++)
                        phenoDep[nb2 + j] = pheno[nb3 + j];
                    
                    chrTemp2 = (*(pop[parDep[ind]]));
                    
                }
                
                else
                {
                    
                    rd = rnd.rand();
                    if (rd < 0.5)
                        rec(chrTemp2, *(pop[parDep[ind]]), *(pop[parDep[ind] + 1]), nbCo, nbSv, nbselfv, nbneutv, modpos, neutpos);
                    else
                        rec(chrTemp2, *(pop[parDep[ind] + 1]), *(pop[parDep[ind]]), nbCo, nbSv, nbselfv, nbneutv, modpos, neutpos);
                    
                    
                    for (j = 0; j < nv; j++)
                    {
                        d = 0;
                        for (k = 0; k < nbSv; k++)
                            if (chrTemp2.sel[k] == 1)
                                d += mutations[nv * k + j];
                        phenoDep[nb2 + j] = d;
                    }
                }
                
                
                // fitness of individual i:
                d=0;
                for (j = 0; j < nv; j++)
                {
                    x = phenoDep[nb + j] + phenoDep[nb + nv + j] + sqrn * gasdev();
                    d += x * x; // "d" is the square of the distance to the optimum
                }
                
                
                w = exp(-1/(2*omegav) * pow(d, hQ));
                woutpheno +=w;
                
                wincond = fitness(chrTemp1, chrTemp2, Whet, Whom);
                woutincond += wincond;
                
                w *= wincond;
                wout += w;
                
                if (w > 0)
                {
                    lnwout += log(w);
                    cmpt++;
                }
                
                
            }
            
            
            wout /= smpv;
            woutincond /= smpv;
            woutpheno /= smpv;
            lnwout /= cmpt;
            
            
            // average trait values:
            mouttot = 0;
            vouttot = 0;
            
            for (i = 0; i < nv; i++)
            {
                mout[i] = 0;
                vout[i] = 0;
            }
            for (i = 0; i < smpv; i++)
            {
                nb = twon * i;
                for (j = 0; j < nv; j++)
                    mout[j] += (phenoDep[nb + j] + phenoDep[nb + nv + j]);
            }
            for (i = 0; i < nv; i++){
                mout[i] /= smpv;
                mouttot += mout[i];
            }
            
            // variances:
            
            for (i = 0; i < smpv; i++)
            {
                nb = twon * i;
                for (j = 0; j < nv; j++)
                    vout[j] += pow(phenoDep[nb + j] + phenoDep[nb + nv + j] - mout[j], 2);
            }
            for (i = 0; i < nv; i++){
                vout[i] /= smpv;
                vouttot += vout[i];
            }
            
            // sampling parents for selfed offspring:
            
            for (i = 0; i < smpv; i++)
            {
                parDep[2*i] = 2 * int(rnd.randExc() * Nv);
                parDep[2*i+1] = parDep[2*i];
            }
            
            // recombination:
            
            // recombination and individual phenotypes and fitnesses:
            wself = 0;
            lnwself = 0;
            cmpt = 0;
            
            for (nb = 0; nb < smpv; nb++)
            {
                
                // maternal sampled parent
                ind = 2*nb;
                nb2 = nv * ind;
                nbCo = int(poisdev(Lv));
                
                
                // if no mutation or cross-over on chromosome segment:
                
                if (nbCo == 0)
                {
                    rd = rnd.rand();
                    if (rd < 0.5)
                        parent = parDep[ind];
                    else
                        parent = parDep[ind] + 1;
                    
                    nb3 = nv * parent;
                    for (j = 0; j < nv; j++)
                        phenoDep[nb2 + j] = pheno[nb3 + j];
                    
                    chrTemp1 = (*(pop[parDep[ind]]));
                    
                }
                else
                {
                    
                    rd = rnd.rand();
                    if (rd < 0.5)
                        rec(chrTemp1, *(pop[parDep[ind]]), *(pop[parDep[ind] + 1]), nbCo, nbSv, nbselfv, nbneutv, modpos, neutpos);
                    else
                        rec(chrTemp1, *(pop[parDep[ind] + 1]), *(pop[parDep[ind]]), nbCo, nbSv, nbselfv, nbneutv, modpos, neutpos);
                    
                    
                    for (j = 0; j < nv; j++)
                    {
                        d = 0;
                        for (k = 0; k < nbSv; k++)
                            if (chrTemp1.sel[k] == 1)
                                d += mutations[nv * k + j];
                        phenoDep[nb2 + j] = d;
                    }
                }
                
                // Paternal sampled parent
                ind = (2*nb) + 1;
                nb2 = nv * ind;
                nbCo = int(poisdev(Lv));
                
                
                // if no mutation or cross-over on chromosome segment:
                
                if (nbCo == 0)
                {
                    rd = rnd.rand();
                    if (rd < 0.5)
                        parent = parDep[ind];
                    else
                        parent = parDep[ind] + 1;
                    
                    nb3 = nv * parent;
                    for (j = 0; j < nv; j++)
                        phenoDep[nb2 + j] = pheno[nb3 + j];
                    
                    chrTemp2 = (*(pop[parDep[ind]]));
                    
                }
                
                else
                {
                    
                    rd = rnd.rand();
                    if (rd < 0.5)
                        rec(chrTemp2, *(pop[parDep[ind]]), *(pop[parDep[ind] + 1]), nbCo, nbSv, nbselfv, nbneutv, modpos, neutpos);
                    else
                        rec(chrTemp2, *(pop[parDep[ind] + 1]), *(pop[parDep[ind]]), nbCo, nbSv, nbselfv, nbneutv, modpos, neutpos);
                    
                    
                    for (j = 0; j < nv; j++)
                    {
                        d = 0;
                        for (k = 0; k < nbSv; k++)
                            if (chrTemp2.sel[k] == 1)
                                d += mutations[nv * k + j];
                        phenoDep[nb2 + j] = d;
                    }
                }
                
                
                // fitness of individual i:
                d=0;
                for (j = 0; j < nv; j++)
                {
                    x = phenoDep[nb + j] + phenoDep[nb + nv + j] + sqrn * gasdev();
                    d += x * x; // "d" is the square of the distance to the optimum
                }
                
                
                w = exp(-1/(2*omegav) * pow(d, hQ));
                wselfpheno +=w;
                
                wincond = fitness(chrTemp1, chrTemp2, Whet, Whom);
                wselfincond += wincond;
                
                w *= wincond;
                wself += w;
                
                if (w > 0)
                {
                    lnwself += log(w);
                    cmpt++;
                }
                
                
            }
            
            
            wself /= smpv;
            wselfincond /= smpv;
            wselfpheno /= smpv;
            lnwself /= cmpt;
            
            
            mselftot = 0;
            vselftot = 0;
            
            // average trait values:
            
            for (i = 0; i < nv; i++)
            {
                mself[i] = 0;
                vself[i] = 0;
            }
            for (i = 0; i < smpv; i++)
            {
                nb = twon * i;
                for (j = 0; j < nv; j++)
                    mself[j] += (phenoDep[nb + j] + phenoDep[nb + nv + j]);
            }
            for (i = 0; i < nv; i++){
                mself[i] /= smpv;
                mselftot += mself[i];
            }
            
            // variances:
            
            for (i = 0; i < smpv; i++)
            {
                nb = twon * i;
                for (j = 0; j < nv; j++)
                    vself[j] += pow(phenoDep[nb + j] + phenoDep[nb + nv + j] - mself[j], 2);
            }
            for (i = 0; i < nv; i++){
                vself[i] /= smpv;
                vselftot += vself[i];
            }
            
            
            
            // number of unconditionally deleterious mutations per chromosome, neutral diversity:
            
            
            le = 0;
            
            for (i = 0; i < fourN; i++)
            {
                if (Chrm[i].nbchr > 0)
                {
                    le += Chrm[i].nbchr * Chrm[i].incond.size();
                    
                }
            }
            
            
            double divtot =0;
            for (k =0; k < nbneutv; k++){
                Fr.clear();
                for (i = 0; i < fourN; i++)
                {
                    if (Chrm[i].nbchr > 0)
                    {
                        frs = Fr.size();
                        for (j = 0; j < frs; j++)
                            if (Fr[j].all == Chrm[i].neut[k])
                            {
                                Fr[j].freq += Chrm[i].nbchr;
                                break;
                            }
                        if (j == frs)
                        {
                            allTemp.all = Chrm[i].neut[k];
                            allTemp.freq = Chrm[i].nbchr;
                            Fr.push_back(allTemp);
                        }
                    }
                }
                
                frs = Fr.size();
                div = 0;
                for (j = 0; j < frs; j++)
                {
                    pp = Fr[j].freq / twoN;
                    div += pp * pp;
                }
                divtot += div;
            }
            
            divtot /= double(nbneutv);
            
            
            fout << divtot << " " << wbar << " " << varw - (wbar*wbar) << " " << lnwbar << " " << lnvarw - (lnwbar*lnwbar) << " " << wphenobar << " " << varwpheno - (wphenobar*wphenobar) <<  " " << wincondbar << " " << varwincond - (wincondbar*wincondbar) << " " << le / twoN
            << " " << wself << " " << wout << " " << lnwself << " " << lnwout<< " "<< wselfincond << " " << woutincond << " " << wselfpheno << " " << woutpheno;
            
            fout << " " << mtot << " " << vtot<< " "<< vsquared << " " << m3 << " " << m4 << " "
            << m5 << " " << m6 << " " << mstot << " " << vstot
            << " " << mouttot << " " << vouttot << " " << mselftot << " " << vselftot << " " << Sbar << " " << Sgbar << " " << Sgbarsel << " " << varS - (Sgbar*Sgbar)<< " "<< Smin << " " << Smax << " " << Third << " " << Cov;
            fout << endl;
        }
        
        
        // sampling parents for the next generation:
        
        for (j = 0; j < Nv; j++)
        {
            nb = 2*j;
            
            do{
                chr1 = int(rnd.randExc() * twoN);
                prem1 = chr1 / 2;
                
                
            } while (rnd.rand() > Wtot[prem1] / wmax);

            par[nb] = 2 * prem1;
            rd = rnd.rand();
            
            // selfing:
            
            if (rd < selfing[prem1])
                par[nb + 1] = 2 * prem1;
            
            // outcrossing:
            
            else
            {
                do{
                    chr1 = int(rnd.randExc() * twoN);
                    prem1 = chr1 / 2;
                    
                } while (rnd.rand() > (1- selfing[prem1]*kappav)*Wtot[prem1] / wmmax);
                
                par[nb + 1] = 2 * prem1;
            }
        }
        
        
        free = 0;
        
        for (nb = 0; nb < twoN; nb++)
        {
            nb2 = nv * nb;
            
            nbCo = int(poisdev(Lv));
            mut = int(poisdev(Uv)); // number of mutations at selected loci
            mutincond = int(poisdev(Udelv)); // number of mutations at unconditionally deleterious loci;
            muM = int(binldev(uneutv, nbneutv));
            
            // mutation at loci affecting selfing :
            
            if (gen > NbGenPreliv)
            {
                mutS = int(binldev(uself,nbselfv));
            }
            else {mutS = 0;}
            
            // if no mutation or cross-over:
            
            if ((mut == 0) && (muM == 0) && (nbCo == 0)&&(mutS == 0) &&(mutincond == 0))
            {
                rd = rnd.rand();
                if (rd < 0.5)
                    parent = par[nb];
                else
                    parent = par[nb] + 1;
                temp[nb] = pop[parent];
                nb3 = nv * parent;
                for (j = 0; j < nv; j++)
                    phenoTemp[nb2 + j] = pheno[nb3 + j];
                
            }
            
            else
            {
                // looking for a free entry in "Chrm" table:
                
                while (Chrm[free].nbchr > 0)
                    free++;
                
                Chrm[free].incond.clear();
               
                
                // if no cross-over:
                
                if ((nbCo == 0) || (pop[par[nb]] == pop[par[nb] + 1]))
                {
                    rd = rnd.rand();
                    if (rd < 0.5)
                        parent = par[nb];
                    else
                        parent = par[nb] + 1;
                    
                    Chrm[free].sel = (*(pop[parent])).sel;
                    
                    ind = (*(pop[parent])).incond.size();
                    for (k =0; k< ind; k++){
                        Chrm[free].incond.push_back((*(pop[parent])).incond[k]);
                    }
                    
                    for (k =0; k< nbneutv; k++){
                        Chrm[free].neut[k] = (*(pop[parent])).neut[k];
                    }
                    for (k =0; k< nbselfv; k++){
                        Chrm[free].selfing[k] = (*(pop[parent])).selfing[k];
                    }
                    nb3 = nv * parent;
                    for (j = 0; j < nv; j++)
                        phenoTemp[nb2 + j] = pheno[nb3 + j];
                }
                // if cross-over:
  
                else
                {
                   
                    
                    rd = rnd.rand();
                    if (rd < 0.5)
                        rec(Chrm[free], *(pop[par[nb]]), *(pop[par[nb] + 1]), nbCo, nbSv, nbselfv, nbneutv, modpos, neutpos);
                    else
                        rec(Chrm[free], *(pop[par[nb] + 1]), *(pop[par[nb]]), nbCo, nbSv, nbselfv, nbneutv, modpos, neutpos);
                    
                    for (j = 0; j < nv; j++)
                    {
                        d = 0;
                        for (k = 0; k < nbSv; k++)
                            if (Chrm[free].sel[k] == 1)
                                d += mutations[nv * k + j];
                        phenoTemp[nb2 + j] = d;
                    }
                    
                }
                
                // if mutation at neutral locus:
                
                posmut.clear();
                
                for (nm = 0; nm < muM; nm++)
                {
                    do {
                        site = rnd.randInt(nbn1);
                    } while (find(posmut.begin(), posmut.end(), site) != posmut.end());
                    
                    posmut.push_back(site);
                    Chrm[free].neut[site] = rnd.rand();
                }
                
                // mutations at selected loci:
                
                for (j = 0; j < mut; j++)
                {
                    site = int(nbSv * rnd.randExc());
                    ns = nv * site;
                    if (Chrm[free].sel[site] == 1)
                        for (k = 0; k < nv; k++)
                            phenoTemp[nb2 + k] -= mutations[ns + k];
                    else
                        for (k = 0; k < nv; k++)
                            phenoTemp[nb2 + k] += mutations[ns + k];
                    Chrm[free].sel.flip(site);
                }
             
                //mutations at uncondtionally deleterious loci
             
                for (j = 0; j < mutincond; j++) // find position for each mutation
                {
                    // each mutation has a random position between 0 and nbS_1:
                    d = nbS_1 * rnd.rand();
                    Chrm[free].incond.push_back(d);
                    sort(Chrm[free].incond.begin(), Chrm[free].incond.end()); // mutations in order

                }
                
                // mutations at selfing loci
                posmut.clear();
                
                for (nm = 0; nm < mutS; nm++)
                {
                    do {
                        site = rnd.randInt(nbm1);
                    } while (find(posmut.begin(), posmut.end(), site) != posmut.end());
                    
                    posmut.push_back(site);
                    dg = sigself * gasdev();
                    Chrm[free].selfing[site] += dg;
                }
                
                temp[nb] = &Chrm[free];
                free++;
               
            }
        }
        
        
        // update population:
        
        for (i = 0; i < fourN; i++)
            Chrm[i].nbchr = 0;
        
        for (i = 0; i < twonN; i++)
            pheno[i] = phenoTemp[i];
        
        for (i = 0; i < twoN; i++)
        {
            pop[i] = temp[i];
            (*(pop[i])).nbchr++;
        }
        
        
    }
    
    fin = time(0);
    
    // writes in output file:
    fprintf(fichierS, "\n\nResultats dans fichier ");
    fprintf(fichierS, nomFichier);
    fprintf(fichierS, "\nsbar = %g\n", sbar);
    
    // time length:
    int temps = int(difftime(fin, debut));
    fprintf(fichierS,
            "\n%d generations ont pris %d heure(s) %d minute(s) %d secondes\n",
            NbGenv, temps / 3600, (temps % 3600) / 60, temps % 60);
    
    // date and time:
    ptr=localtime(&fin);
    fprintf(fichierS, asctime(ptr));
    
    delete [] pop;
    delete [] temp;
    delete [] Chrm;
    delete [] mutations;
    delete [] pheno;
    delete [] phenoTemp;
    delete [] phenoDep;
    delete [] Wtot;
    delete [] par;
    delete [] parDep;
    delete [] m;
    delete [] v;
    delete [] ms;
    delete [] vs;
    delete [] mout;
    delete [] vout;
    delete [] mself;
    delete [] vself;
    delete [] Vg;
    delete [] Vgintra;
}
